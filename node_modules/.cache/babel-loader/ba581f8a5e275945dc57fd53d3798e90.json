{"ast":null,"code":"var isBrowser = typeof window !== 'undefined';\nvar Masonry = isBrowser ? window.Masonry || require('masonry-layout') : null;\nvar imagesloaded = isBrowser ? require('imagesloaded') : null;\n\nvar assign = require('lodash/assign');\n\nvar elementResizeDetectorMaker = require('element-resize-detector');\n\nvar debounce = require('lodash/debounce');\n\nvar omit = require('lodash/omit');\n\nvar PropTypes = require('prop-types');\n\nvar React = require('react');\n\nvar createReactClass = require('create-react-class');\n\nvar propTypes = {\n  enableResizableChildren: PropTypes.bool,\n  disableImagesLoaded: PropTypes.bool,\n  onImagesLoaded: PropTypes.func,\n  updateOnEachImageLoad: PropTypes.bool,\n  options: PropTypes.object,\n  imagesLoadedOptions: PropTypes.object,\n  elementType: PropTypes.string,\n  onLayoutComplete: PropTypes.func,\n  onRemoveComplete: PropTypes.func\n};\nvar MasonryComponent = createReactClass({\n  masonry: false,\n  erd: undefined,\n  latestKnownDomChildren: [],\n  displayName: 'MasonryComponent',\n  imagesLoadedCancelRef: undefined,\n  propTypes: propTypes,\n  getDefaultProps: function () {\n    return {\n      enableResizableChildren: false,\n      disableImagesLoaded: false,\n      updateOnEachImageLoad: false,\n      options: {},\n      imagesLoadedOptions: {},\n      className: '',\n      elementType: 'div',\n      onLayoutComplete: function () {},\n      onRemoveComplete: function () {}\n    };\n  },\n  initializeMasonry: function (force) {\n    if (!this.masonry || force) {\n      this.masonry = new Masonry(this.masonryContainer, this.props.options);\n\n      if (this.props.onLayoutComplete) {\n        this.masonry.on('layoutComplete', this.props.onLayoutComplete);\n      }\n\n      if (this.props.onRemoveComplete) {\n        this.masonry.on('removeComplete', this.props.onRemoveComplete);\n      }\n\n      this.latestKnownDomChildren = this.getCurrentDomChildren();\n    }\n  },\n  getCurrentDomChildren: function () {\n    var node = this.masonryContainer;\n    var children = this.props.options.itemSelector ? node.querySelectorAll(this.props.options.itemSelector) : node.children;\n    return Array.prototype.slice.call(children);\n  },\n  diffDomChildren: function () {\n    var forceItemReload = false;\n    var knownChildrenStillAttached = this.latestKnownDomChildren.filter(function (element) {\n      /*\n       * take only elements attached to DOM\n       * (aka the parent is the masonry container, not null)\n       * otherwise masonry would try to \"remove it\" again from the DOM\n       */\n      return !!element.parentNode;\n    });\n    /*\n     * If not all known children are attached to the dom - we have no other way of notifying\n     * masonry to remove the ones not still attached besides invoking a complete item reload.\n     * basically all the rest of the code below does not matter in that case.\n     */\n\n    if (knownChildrenStillAttached.length !== this.latestKnownDomChildren.length) {\n      forceItemReload = true;\n    }\n\n    var currentDomChildren = this.getCurrentDomChildren();\n    /*\n     * Since we are looking for a known child which is also attached to the dom AND\n     * not attached to the dom at the same time - this would *always* produce an empty array.\n     */\n\n    var removed = knownChildrenStillAttached.filter(function (attachedKnownChild) {\n      return !~currentDomChildren.indexOf(attachedKnownChild);\n    });\n    /*\n     * This would get any children which are attached to the dom but are *unkown* to us\n     * from previous renders\n     */\n\n    var newDomChildren = currentDomChildren.filter(function (currentChild) {\n      return !~knownChildrenStillAttached.indexOf(currentChild);\n    });\n    var beginningIndex = 0; // get everything added to the beginning of the DOMNode list\n\n    var prepended = newDomChildren.filter(function (newChild) {\n      var prepend = beginningIndex === currentDomChildren.indexOf(newChild);\n\n      if (prepend) {\n        // increase the index\n        beginningIndex++;\n      }\n\n      return prepend;\n    }); // we assume that everything else is appended\n\n    var appended = newDomChildren.filter(function (el) {\n      return prepended.indexOf(el) === -1;\n    });\n    /*\n     * otherwise we reverse it because so we're going through the list picking off the items that\n     * have been added at the end of the list. this complex logic is preserved in case it needs to be\n     * invoked\n     *\n     * var endingIndex = currentDomChildren.length - 1;\n     *\n     * newDomChildren.reverse().filter(function(newChild, i){\n     *     var append = endingIndex == currentDomChildren.indexOf(newChild);\n     *\n     *     if (append) {\n     *         endingIndex--;\n     *     }\n     *\n     *     return append;\n     * });\n     */\n    // get everything added to the end of the DOMNode list\n\n    var moved = [];\n    /*\n     * This would always be true (see above about the lofic for \"removed\")\n     */\n\n    if (removed.length === 0) {\n      /*\n       * 'moved' will contain some random elements (if any) since the \"knownChildrenStillAttached\" is a filter\n       * of the \"known\" children which are still attached - All indexes could basically change. (for example\n       * if the first element is not attached)\n       * Don't trust this array.\n       */\n      moved = knownChildrenStillAttached.filter(function (child, index) {\n        return index !== currentDomChildren.indexOf(child);\n      });\n    }\n\n    this.latestKnownDomChildren = currentDomChildren;\n    return {\n      old: knownChildrenStillAttached,\n      // Not used\n      new: currentDomChildren,\n      // Not used\n      removed: removed,\n      appended: appended,\n      prepended: prepended,\n      moved: moved,\n      forceItemReload: forceItemReload\n    };\n  },\n  performLayout: function () {\n    var diff = this.diffDomChildren();\n    var reloadItems = diff.forceItemReload || diff.moved.length > 0; // Would never be true. (see comments of 'diffDomChildren' about 'removed')\n\n    if (diff.removed.length > 0) {\n      if (this.props.enableResizableChildren) {\n        diff.removed.forEach(this.erd.removeAllListeners, this.erd);\n      }\n\n      this.masonry.remove(diff.removed);\n      reloadItems = true;\n    }\n\n    if (diff.appended.length > 0) {\n      this.masonry.appended(diff.appended);\n\n      if (diff.prepended.length === 0) {\n        reloadItems = true;\n      }\n\n      if (this.props.enableResizableChildren) {\n        diff.appended.forEach(this.listenToElementResize, this);\n      }\n    }\n\n    if (diff.prepended.length > 0) {\n      this.masonry.prepended(diff.prepended);\n\n      if (this.props.enableResizableChildren) {\n        diff.prepended.forEach(this.listenToElementResize, this);\n      }\n    }\n\n    if (reloadItems) {\n      this.masonry.reloadItems();\n    }\n\n    this.masonry.layout();\n  },\n  derefImagesLoaded: function () {\n    this.imagesLoadedCancelRef();\n    this.imagesLoadedCancelRef = undefined;\n  },\n  imagesLoaded: function () {\n    if (this.props.disableImagesLoaded) {\n      return;\n    }\n\n    if (this.imagesLoadedCancelRef) {\n      this.derefImagesLoaded();\n    }\n\n    var event = this.props.updateOnEachImageLoad ? 'progress' : 'always';\n    var handler = debounce(function (instance) {\n      if (this.props.onImagesLoaded) {\n        this.props.onImagesLoaded(instance);\n      }\n\n      this.masonry.layout();\n    }.bind(this), 100);\n    var imgLoad = imagesloaded(this.masonryContainer, this.props.imagesLoadedOptions).on(event, handler);\n\n    this.imagesLoadedCancelRef = function () {\n      imgLoad.off(event, handler);\n      handler.cancel();\n    };\n  },\n  initializeResizableChildren: function () {\n    if (!this.props.enableResizableChildren) {\n      return;\n    }\n\n    this.erd = elementResizeDetectorMaker({\n      strategy: 'scroll'\n    });\n    this.latestKnownDomChildren.forEach(this.listenToElementResize, this);\n  },\n  listenToElementResize: function (el) {\n    this.erd.listenTo(el, function () {\n      this.masonry.layout();\n    }.bind(this));\n  },\n  destroyErd: function () {\n    if (this.erd) {\n      this.latestKnownDomChildren.forEach(this.erd.uninstall, this.erd);\n    }\n  },\n  componentDidMount: function () {\n    this.initializeMasonry();\n    this.initializeResizableChildren();\n    this.imagesLoaded();\n  },\n  componentDidUpdate: function () {\n    this.performLayout();\n    this.imagesLoaded();\n  },\n  componentWillUnmount: function () {\n    this.destroyErd(); // unregister events\n\n    if (this.props.onLayoutComplete) {\n      this.masonry.off('layoutComplete', this.props.onLayoutComplete);\n    }\n\n    if (this.props.onRemoveComplete) {\n      this.masonry.off('removeComplete', this.props.onRemoveComplete);\n    }\n\n    if (this.imagesLoadedCancelRef) {\n      this.derefImagesLoaded();\n    }\n\n    this.masonry.destroy();\n  },\n  setRef: function (n) {\n    this.masonryContainer = n;\n  },\n  render: function () {\n    var props = omit(this.props, Object.keys(propTypes));\n    return React.createElement(this.props.elementType, assign({}, props, {\n      ref: this.setRef\n    }), this.props.children);\n  }\n});\nmodule.exports = MasonryComponent;\nmodule.exports.default = MasonryComponent;","map":{"version":3,"sources":["/Users/iMaciCode/Downloads/RestroKing-React-v1.0-9_Febuary_2020/restroking-package/node_modules/react-masonry-component/lib/index.js"],"names":["isBrowser","window","Masonry","require","imagesloaded","assign","elementResizeDetectorMaker","debounce","omit","PropTypes","React","createReactClass","propTypes","enableResizableChildren","bool","disableImagesLoaded","onImagesLoaded","func","updateOnEachImageLoad","options","object","imagesLoadedOptions","elementType","string","onLayoutComplete","onRemoveComplete","MasonryComponent","masonry","erd","undefined","latestKnownDomChildren","displayName","imagesLoadedCancelRef","getDefaultProps","className","initializeMasonry","force","masonryContainer","props","on","getCurrentDomChildren","node","children","itemSelector","querySelectorAll","Array","prototype","slice","call","diffDomChildren","forceItemReload","knownChildrenStillAttached","filter","element","parentNode","length","currentDomChildren","removed","attachedKnownChild","indexOf","newDomChildren","currentChild","beginningIndex","prepended","newChild","prepend","appended","el","moved","child","index","old","new","performLayout","diff","reloadItems","forEach","removeAllListeners","remove","listenToElementResize","layout","derefImagesLoaded","imagesLoaded","event","handler","instance","bind","imgLoad","off","cancel","initializeResizableChildren","strategy","listenTo","destroyErd","uninstall","componentDidMount","componentDidUpdate","componentWillUnmount","destroy","setRef","n","render","Object","keys","createElement","ref","module","exports","default"],"mappings":"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","sourcesContent":["var isBrowser = typeof window !== 'undefined';\nvar Masonry = isBrowser ? window.Masonry || require('masonry-layout') : null;\nvar imagesloaded = isBrowser ? require('imagesloaded') : null;\nvar assign = require('lodash/assign');\nvar elementResizeDetectorMaker = require('element-resize-detector');\nvar debounce = require('lodash/debounce');\nvar omit = require('lodash/omit');\nvar PropTypes = require('prop-types');\nvar React = require('react');\nvar createReactClass = require('create-react-class');\n\nvar propTypes = {\n  enableResizableChildren: PropTypes.bool,\n  disableImagesLoaded: PropTypes.bool,\n  onImagesLoaded: PropTypes.func,\n  updateOnEachImageLoad: PropTypes.bool,\n  options: PropTypes.object,\n  imagesLoadedOptions: PropTypes.object,\n  elementType: PropTypes.string,\n  onLayoutComplete: PropTypes.func,\n  onRemoveComplete: PropTypes.func\n};\n\nvar MasonryComponent = createReactClass({\n  masonry: false,\n  erd: undefined,\n  latestKnownDomChildren: [],\n  displayName: 'MasonryComponent',\n  imagesLoadedCancelRef: undefined,\n  propTypes: propTypes,\n\n  getDefaultProps: function() {\n    return {\n      enableResizableChildren: false,\n      disableImagesLoaded: false,\n      updateOnEachImageLoad: false,\n      options: {},\n      imagesLoadedOptions: {},\n      className: '',\n      elementType: 'div',\n      onLayoutComplete: function() {\n      },\n      onRemoveComplete: function() {\n      }\n    };\n  },\n\n  initializeMasonry: function(force) {\n    if (!this.masonry || force) {\n      this.masonry = new Masonry(\n        this.masonryContainer,\n        this.props.options\n      );\n\n      if (this.props.onLayoutComplete) {\n        this.masonry.on('layoutComplete', this.props.onLayoutComplete);\n      }\n\n      if (this.props.onRemoveComplete) {\n        this.masonry.on('removeComplete', this.props.onRemoveComplete);\n      }\n\n      this.latestKnownDomChildren = this.getCurrentDomChildren();\n    }\n  },\n\n  getCurrentDomChildren: function() {\n    var node = this.masonryContainer;\n    var children = this.props.options.itemSelector ? node.querySelectorAll(this.props.options.itemSelector) : node.children;\n    return Array.prototype.slice.call(children);\n  },\n\n  diffDomChildren: function() {\n    var forceItemReload = false;\n\n    var knownChildrenStillAttached = this.latestKnownDomChildren.filter(function(element) {\n      /*\n       * take only elements attached to DOM\n       * (aka the parent is the masonry container, not null)\n       * otherwise masonry would try to \"remove it\" again from the DOM\n       */\n      return !!element.parentNode;\n    });\n\n    /*\n     * If not all known children are attached to the dom - we have no other way of notifying\n     * masonry to remove the ones not still attached besides invoking a complete item reload.\n     * basically all the rest of the code below does not matter in that case.\n     */\n    if (knownChildrenStillAttached.length !== this.latestKnownDomChildren.length) {\n      forceItemReload = true;\n    }\n\n    var currentDomChildren = this.getCurrentDomChildren();\n\n    /*\n     * Since we are looking for a known child which is also attached to the dom AND\n     * not attached to the dom at the same time - this would *always* produce an empty array.\n     */\n    var removed = knownChildrenStillAttached.filter(function(attachedKnownChild) {\n      return !~currentDomChildren.indexOf(attachedKnownChild);\n    });\n\n    /*\n     * This would get any children which are attached to the dom but are *unkown* to us\n     * from previous renders\n     */\n    var newDomChildren = currentDomChildren.filter(function(currentChild) {\n      return !~knownChildrenStillAttached.indexOf(currentChild);\n    });\n\n    var beginningIndex = 0;\n\n    // get everything added to the beginning of the DOMNode list\n    var prepended = newDomChildren.filter(function(newChild) {\n      var prepend = (beginningIndex === currentDomChildren.indexOf(newChild));\n\n      if (prepend) {\n        // increase the index\n        beginningIndex++;\n      }\n\n      return prepend;\n    });\n\n    // we assume that everything else is appended\n    var appended = newDomChildren.filter(function(el) {\n      return prepended.indexOf(el) === -1;\n    });\n\n    /*\n     * otherwise we reverse it because so we're going through the list picking off the items that\n     * have been added at the end of the list. this complex logic is preserved in case it needs to be\n     * invoked\n     *\n     * var endingIndex = currentDomChildren.length - 1;\n     *\n     * newDomChildren.reverse().filter(function(newChild, i){\n     *     var append = endingIndex == currentDomChildren.indexOf(newChild);\n     *\n     *     if (append) {\n     *         endingIndex--;\n     *     }\n     *\n     *     return append;\n     * });\n     */\n\n    // get everything added to the end of the DOMNode list\n    var moved = [];\n\n    /*\n     * This would always be true (see above about the lofic for \"removed\")\n     */\n    if (removed.length === 0) {\n      /*\n       * 'moved' will contain some random elements (if any) since the \"knownChildrenStillAttached\" is a filter\n       * of the \"known\" children which are still attached - All indexes could basically change. (for example\n       * if the first element is not attached)\n       * Don't trust this array.\n       */\n      moved = knownChildrenStillAttached.filter(function(child, index) {\n        return index !== currentDomChildren.indexOf(child);\n      });\n    }\n\n    this.latestKnownDomChildren = currentDomChildren;\n\n    return {\n      old: knownChildrenStillAttached, // Not used\n      new: currentDomChildren, // Not used\n      removed: removed,\n      appended: appended,\n      prepended: prepended,\n      moved: moved,\n      forceItemReload: forceItemReload\n    };\n  },\n\n  performLayout: function() {\n    var diff = this.diffDomChildren();\n    var reloadItems = diff.forceItemReload || diff.moved.length > 0;\n\n    // Would never be true. (see comments of 'diffDomChildren' about 'removed')\n    if (diff.removed.length > 0) {\n      if (this.props.enableResizableChildren) {\n        diff.removed.forEach(this.erd.removeAllListeners, this.erd);\n      }\n      this.masonry.remove(diff.removed);\n      reloadItems = true;\n    }\n\n    if (diff.appended.length > 0) {\n      this.masonry.appended(diff.appended);\n\n      if (diff.prepended.length === 0) {\n        reloadItems = true;\n      }\n\n      if (this.props.enableResizableChildren) {\n        diff.appended.forEach(this.listenToElementResize, this);\n      }\n    }\n\n    if (diff.prepended.length > 0) {\n      this.masonry.prepended(diff.prepended);\n\n      if (this.props.enableResizableChildren) {\n        diff.prepended.forEach(this.listenToElementResize, this);\n      }\n    }\n\n    if (reloadItems) {\n      this.masonry.reloadItems();\n    }\n\n    this.masonry.layout();\n  },\n\n  derefImagesLoaded: function() {\n    this.imagesLoadedCancelRef();\n    this.imagesLoadedCancelRef = undefined;\n  },\n\n  imagesLoaded: function() {\n    if (this.props.disableImagesLoaded) {\n      return;\n    }\n\n    if (this.imagesLoadedCancelRef) {\n      this.derefImagesLoaded();\n    }\n\n    var event = this.props.updateOnEachImageLoad ? 'progress' : 'always';\n    var handler = debounce(\n      function(instance) {\n        if (this.props.onImagesLoaded) {\n          this.props.onImagesLoaded(instance);\n        }\n        this.masonry.layout();\n      }.bind(this), 100);\n\n    var imgLoad = imagesloaded(this.masonryContainer, this.props.imagesLoadedOptions).on(event, handler);\n\n    this.imagesLoadedCancelRef = function() {\n      imgLoad.off(event, handler);\n      handler.cancel();\n    };\n  },\n\n  initializeResizableChildren: function() {\n    if (!this.props.enableResizableChildren) {\n      return;\n    }\n\n    this.erd = elementResizeDetectorMaker({\n      strategy: 'scroll'\n    });\n\n    this.latestKnownDomChildren.forEach(this.listenToElementResize, this);\n  },\n\n  listenToElementResize: function(el) {\n    this.erd.listenTo(el, function() {\n      this.masonry.layout()\n    }.bind(this))\n  },\n\n  destroyErd: function() {\n    if (this.erd) {\n      this.latestKnownDomChildren.forEach(this.erd.uninstall, this.erd);\n    }\n  },\n\n  componentDidMount: function() {\n    this.initializeMasonry();\n    this.initializeResizableChildren();\n    this.imagesLoaded();\n  },\n\n  componentDidUpdate: function() {\n    this.performLayout();\n    this.imagesLoaded();\n  },\n\n  componentWillUnmount: function() {\n    this.destroyErd();\n\n    // unregister events\n    if (this.props.onLayoutComplete) {\n      this.masonry.off('layoutComplete', this.props.onLayoutComplete);\n    }\n\n    if (this.props.onRemoveComplete) {\n      this.masonry.off('removeComplete', this.props.onRemoveComplete);\n    }\n\n    if (this.imagesLoadedCancelRef) {\n      this.derefImagesLoaded();\n    }\n    this.masonry.destroy();\n  },\n  \n  setRef: function(n) {\n    this.masonryContainer = n;\n  },\n\n  render: function() {\n    var props = omit(this.props, Object.keys(propTypes));\n    return React.createElement(this.props.elementType, assign({}, props, {ref: this.setRef}), this.props.children);\n  }\n});\n\nmodule.exports = MasonryComponent;\nmodule.exports.default = MasonryComponent;\n"]},"metadata":{},"sourceType":"script"}